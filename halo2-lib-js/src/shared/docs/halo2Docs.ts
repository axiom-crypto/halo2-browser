export const halo2Docs = "// Generated by dts-bundle-generator v8.0.1\n\n  Bn254FqPoint,\n  Bn254G1AffinePoint,\n  Bn254G2AffinePoint,\n  JsCircuitBn254Fq2,\n  JsCircuitBn254G1Affine,\n  JsCircuitBn254G2Affine,\n  JsCircuitSecp256k1Affine,\n  JsCircuitValue256,\n  Secp256k1AffinePoint,\n} from \"@axiom-crypto/halo2-wasm/web\";\n\ndeclare class CircuitValue {\n  private _value;\n  private _cell;\n  constructor(\n    circuit: Halo2Wasm,\n    {\n      value,\n      cell,\n    }: {\n      value?: bigint | number | string;\n      cell?: number;\n    }\n  );\n  cell(): number;\n  value(): bigint;\n  number(): number;\n  address(): string;\n}\n\ndeclare class CircuitValue256 {\n  private _value;\n  private _circuitValue;\n  private _halo2Lib;\n  constructor(\n    _halo2Lib: Halo2Wasm,\n    {\n      value,\n      hi,\n      lo,\n    }: {\n      value?: bigint | string | number;\n      hi?: CircuitValue;\n      lo?: CircuitValue;\n    }\n  );\n  hi(): CircuitValue;\n  lo(): CircuitValue;\n  hex(): string;\n  value(): bigint;\n  toCircuitValue(): CircuitValue;\n}\n\ninterface CircuitBn254Fq2 {\n  c0: CircuitValue256;\n  c1: CircuitValue256;\n}\n\ninterface CircuitBn254G1Affine {\n  x: CircuitValue256;\n  y: CircuitValue256;\n}\n\ninterface CircuitBn254G2Affine {\n  x: CircuitBn254Fq2;\n  y: CircuitBn254Fq2;\n}\n\ninterface CircuitSecp256k1Affine {\n  x: CircuitValue256;\n  y: CircuitValue256;\n}\n\ntype RawCircuitInput = string | number | bigint;\n\n/**\n * Creates a circuit variable from a number, bigint, or string.\n *\n * @param a The raw circuit input.\n * @returns The witness cell.\n */\ndeclare const witness: (a: RawCircuitInput) => CircuitValue;\n/**\n * Creates a circuit constant from a number, bigint, or string.\n *\n * @param a The raw circuit input.\n * @returns The constant cell.\n */\ndeclare const constant: (a: RawCircuitInput) => CircuitValue;\n/**\n * Adds two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The sum of the two circuit values.\n */\ndeclare const add: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Subtracts the second circuit value from the first circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The difference between the two circuit values.\n */\ndeclare const sub: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Negates a circuit value.\n *\n * @param a The circuit value to negate.\n * @returns The negation of the circuit value.\n */\ndeclare const neg: (a: CircuitValue) => CircuitValue;\n/**\n * Multiplies two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The product of the two circuit values.\n */\ndeclare const mul: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Multiplies two circuit values and adds a third circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The third circuit value.\n * @returns The result of multiplying the first two circuit values and adding the third circuit value.\n */\ndeclare const mulAdd: (\n  a: CircuitValue,\n  b: CircuitValue,\n  c: CircuitValue\n) => CircuitValue;\n/**\n * Multiplies a circuit value by the negation of another circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of multiplying the first circuit value by the negation of the second circuit value.\n */\ndeclare const mulNot: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Asserts that a circuit value is a bit.\n *\n * @param a The circuit value to assert.\n */\ndeclare const assertBit: (a: CircuitValue) => void;\n/**\n * Asserts that a circuit value is a constant.\n *\n * @param a The circuit value to assert.\n * @param b The raw circuit input.\n */\ndeclare const assertIsConst: (a: CircuitValue, b: RawCircuitInput) => void;\n/**\n * Computes the inner product of two arrays of circuit values.\n *\n * @param a The first array of circuit values.\n * @param b The second array of circuit values.\n * @returns The inner product of the two arrays.\n */\ndeclare const innerProduct: (\n  a: CircuitValue[],\n  b: CircuitValue[]\n) => CircuitValue;\n/**\n * Computes the sum of an array of circuit values.\n *\n * @param arr The array of circuit values.\n * @returns The sum of the array of circuit values.\n */\ndeclare const sum: (arr: CircuitValue[]) => CircuitValue;\n/**\n * Performs a bitwise AND operation on two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of the bitwise AND operation.\n */\ndeclare const and: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise OR operation on two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of the bitwise OR operation.\n */\ndeclare const or: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise NOT operation on a circuit value.\n *\n * @param a The circuit value.\n * @returns The result of the bitwise NOT operation.\n */\ndeclare const not: (a: CircuitValue) => CircuitValue;\n/**\n * Decrements a circuit value by 1.\n *\n * @param a The circuit value.\n * @returns The decremented circuit value.\n */\ndeclare const dec: (a: CircuitValue) => CircuitValue;\n/**\n * Selects a circuit value based on a condition.\n *\n * @param a The first circuit value.\n * @param b The first circuit value.\n * @param sel The condition boolean circuit value.\n * @returns sel ? a : b\n */\ndeclare const select: (\n  a: CircuitValue,\n  b: CircuitValue,\n  sel: CircuitValue\n) => CircuitValue;\n/**\n * Performs a bitwise OR-AND operation on three circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The third circuit value.\n * @returns The result of the OR-AND operation.\n */\ndeclare const orAnd: (\n  a: CircuitValue,\n  b: CircuitValue,\n  c: CircuitValue\n) => CircuitValue;\n/**\n * Converts an array of circuit values to an indicator array.\n *\n * @param bits The array of circuit values.\n * @returns The indicator circuit value.\n */\ndeclare const bitsToIndicator: (bits: CircuitValue[]) => CircuitValue[];\n/**\n * Converts an index circuit value to an indicator circuit value.\n *\n * @param idx The index circuit value.\n * @param len The length of the indicator circuit value.\n * @returns The indicator circuit value.\n */\ndeclare const idxToIndicator: (\n  idx: CircuitValue,\n  len: RawCircuitInput\n) => CircuitValue[];\n/**\n * Selects circuit values from an array based on an indicator circuit value.\n *\n * @param arr The array of circuit values.\n * @param indicator The indicator circuit value.\n * @returns The selected circuit values.\n */\ndeclare const selectByIndicator: (\n  arr: CircuitValue[],\n  indicator: CircuitValue[]\n) => CircuitValue;\n/**\n * Selects a circuit value from an array based on an index circuit value.\n *\n * @param arr The array of circuit values.\n * @param idx The index circuit value.\n * @returns The selected circuit value.\n */\ndeclare const selectFromIdx: (\n  arr: CircuitValue[],\n  idx: CircuitValue\n) => CircuitValue;\n/**\n * Checks if a circuit value is zero.\n *\n * @param a The circuit value to check.\n * @returns The indicator circuit value representing whether the input is zero.\n */\ndeclare const isZero: (a: CircuitValue) => CircuitValue;\n/**\n * Checks if two circuit values are equal.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The indicator circuit value representing whether the two inputs are equal.\n */\ndeclare const isEqual: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Converts a circuit value to an array of bits.\n *\n * @param a The circuit value to convert.\n * @param len The length of the resulting bit array.\n * @returns The array of bits representing the input circuit value.\n */\ndeclare const numToBits: (\n  a: CircuitValue,\n  len: RawCircuitInput\n) => CircuitValue[];\n/**\n * Asserts that two circuit values are equal.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n */\ndeclare const checkEqual: (a: CircuitValue, b: CircuitValue) => void;\n/**\n * Checks if a circuit value is within a specified range.\n *\n * @param a The circuit value to check.\n * @param b The range of the circuit value.\n */\ndeclare const rangeCheck: (a: CircuitValue, b: RawCircuitInput) => void;\n/**\n * Checks if the first circuit value is less than the second circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The range of the circuit values.\n */\ndeclare const checkLessThan: (\n  a: CircuitValue,\n  b: CircuitValue,\n  c?: string\n) => void;\n/**\n * Checks if the first circuit value is less than the second circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The range of the circuit values.\n * @returns The indicator circuit value representing whether the first input is less than the second input.\n */\ndeclare const isLessThan: (\n  a: CircuitValue,\n  b: CircuitValue,\n  c?: string\n) => CircuitValue;\n/**\n * Divides two circuit values and returns the quotient.\n *\n * @param a The dividend circuit value.\n * @param b The divisor circuit value.\n * @returns The quotient.\n *\n */\ndeclare const div: (\n  a: CircuitValue,\n  b: CircuitValue,\n  c?: string,\n  d?: string\n) => CircuitValue;\n/**\n * Divides two circuit values and returns the remainder.\n *\n * @param a The dividend circuit value.\n * @param b The divisor circuit value.\n * @returns The remainder.\n *\n */\ndeclare const mod: (\n  a: CircuitValue,\n  b: CircuitValue,\n  c?: string,\n  d?: string\n) => CircuitValue;\n/**\n * Raises a circuit value to the power of another circuit value.\n *\n * @param a The base circuit value.\n * @param b The exponent circuit value.\n * @returns The result of the exponentiation.\n */\ndeclare const pow: (\n  a: CircuitValue,\n  b: CircuitValue,\n  c?: string\n) => CircuitValue;\n/**\n * Computes the Poseidon hash of multiple circuit values.\n *\n * @param args The circuit values to hash.\n * @returns The hash value.\n */\ndeclare const poseidon: (...args: CircuitValue[]) => CircuitValue;\n/**\n * Retrieves the value of a circuit value.\n *\n * @param a The circuit value.\n * @returns The value of the circuit value.\n */\ndeclare const value: (a: CircuitValue) => any;\n/**\n * Logs the provided *circuit* values to the console. Use `console.log` for normal logging.\n *\n * @param args The `CircuitValue`s to log.\n */\ndeclare const log: (...args: any) => void;\ndeclare const console: {\n  /**\n   * Logs any *non CircuitValue* to the console. Use `log` for logging `CircuitValue`s.\n   * @param args The values to log.\n   */\n  log: (...args: any) => void;\n};\ndeclare const ecdsaBenchmark: (\n  sk: bigint,\n  msg_hash: bigint,\n  k: bigint\n) => CircuitValue;\n\n/**\n * Creates new `CircuitValue256` and range checks `hi, lo` to be `uint128`s.\n * @param hi\n * @param lo\n * @returns\n */\ndeclare const newCircuitValue256: (\n  hi: CircuitValue,\n  lo: CircuitValue\n) => CircuitValue256;\n//ecc\n\n/**\n *\n * @param val The field point to load, in hi-lo form. The hi, lo values must have been constrained to be `uint128`s.\n * @returns `Bn254FqPoint` whose internals are opaque to the user.\n */\ndeclare const loadBn254Fq: (val: CircuitValue256) => Bn254FqPoint;\n\n/**\n *\n * @param val\n * @returns `val` in hi-lo form\n */\ndeclare const convertBn254FqToCircuitValue256: (\n  val: Bn254FqPoint\n) => CircuitValue256;\n\n/**\n * @param point The affine point to load, with coordinates `CircuitValue256`. The hi, lo values must have been constrained to be `uint128`s.\n * @returns `Bn254G1AffinePoint`, which has been constrained to lie on the curve. Currently this point is not allowed to be identity (0, 0).\n */\ndeclare const loadBn254G1: (point: CircuitBn254G1Affine) => Bn254G1AffinePoint;\n\n/**\n * Sums the values of the provided G1 affine points\n *\n * @param points - The array of `CircuitBn254G1Affine` points. All coordinates are in hi, lo form, and we assume they have been range checked to be `uint128`s.\n * @returns The sum of all these points as `Bn254G1AffinePoint`.\n */\ndeclare const bn254G1Sum: (\n  points: Array<CircuitBn254G1Affine>\n) => Bn254G1AffinePoint;\n\n/**\n * Subtracts the 2 points and returns the value. Constrains that the points are not equal and also one is not the negative of the other (this would be a point doubling, which requires a different formula).\n *\n * @returns The subtraction of these points.\n * @param g1Point1 - G1 point, x,y in hi lo format for each coordinate\n * @param g1Point2 - G1 point, x,y in hi lo format for each coordinate\n */\ndeclare const bn254G1SubUnequal: (\n  g1Point1: CircuitBn254G1Affine,\n  g1Point2: CircuitBn254G1Affine\n) => Bn254G1AffinePoint;\n\n/**\n * @param point The affine point to load, with coordinates `CircuitBn254Fq2`. The hi, lo values must have been constrained to be `uint128`s.\n * @returns `Bn254G2AffinePoint`, which has been constrained to lie on the curve. Currently this point is not allowed to be identity (Fq2(0), Fq2(0)).\n */\ndeclare const loadBn254G2: (point: CircuitBn254G2Affine) => Bn254G2AffinePoint;\n\n/**\n * Sums the values of the provided G2 affine points\n *\n * @param points - The array of `CircuitBn254G2Affine` points. All coordinates are `CircuitBn254Fq2`, whose coordinates are in hi, lo form, and we assume the hi, lo's have been range checked to be `uint128`s.\n * @returns The sum of all these points as `Bn254G2AffinePoint`.\n */\ndeclare const bn254G2Sum: (\n  points: Array<CircuitBn254G2Affine>\n) => Bn254G2AffinePoint;\n\n/**\n * Verifies that e(lhsG1, lhsG2) = e(rhsG1, rhsG2) by checking e(lhsG1, lhsG2)*e(-rhsG1, rhsG2) === 1\n * None of the points should be identity.\n *\n * @param lhsG1\n * @param lhsG2\n * @param rhsG1\n * @param rhsG2\n * @returns [CircuitValue] for the result as a boolean (1 if signature verification is successful).\n */\ndeclare const bn254PairingCheck: (\n  lhsG1: Bn254G1AffinePoint,\n  lhsG2: Bn254G2AffinePoint,\n  rhsG1: Bn254G1AffinePoint,\n  rhsG2: Bn254G2AffinePoint\n) => CircuitValue;\n\n/**\n * @param pubkey The public key to load, in the form of an affine elliptic curve point `(x, y)` where `x, y` have type `CircuitValue256`. The hi, lo values of each `CircuitValue256` must have been constrained to be `uint128`s.\n * @returns `Secp256k1AffinePoint`, the public key as a loaded elliptic curve point. This has been constrained to lie on the curve. The public key is constrained to not be the identity (0, 0).\n */\ndeclare const loadSecp256k1Pubkey: (\n  pubkey: CircuitSecp256k1Affine\n) => Secp256k1AffinePoint;\n\n/**\n *\n * Verifies the ECDSA signature `(r, s)` with message hash `msgHash` using the secp256k1 public key `pubkey`. Returns 1 if the signature is valid, 0 otherwise.\n * @param pubkey\n * @param r\n * @param s\n * @param msgHash\n * @returns\n */\ndeclare const verifySecp256k1ECDSASignature: (\n  pubkey: Secp256k1AffinePoint,\n  r: CircuitValue256,\n  s: CircuitValue256,\n  msgHash: CircuitValue256\n) => CircuitValue;\n";