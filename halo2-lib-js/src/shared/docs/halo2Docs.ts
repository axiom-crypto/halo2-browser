export const halo2Docs = "// Generated by dts-bundle-generator v8.1.2\n\ninterface CircuitStats {\n\tadvice: number;\n\tlookup: number;\n\tfixed: number;\n\tinstance: number;\n\tk: number;\n}\ninterface CircuitConfig {\n\tk: number;\n\tnumAdvice: number;\n\tnumLookupAdvice: number;\n\tnumInstance: number;\n\tnumLookupBits: number;\n\tnumVirtualInstance: number;\n}\ndeclare class Bn254Fq2Point {\n\tfree(): void;\n\t/**\n\t* @returns {Bn254FqPoint}\n\t*/\n\tc0(): Bn254FqPoint;\n\t/**\n\t* @returns {Bn254FqPoint}\n\t*/\n\tc1(): Bn254FqPoint;\n}\ndeclare class Bn254FqPoint {\n\tfree(): void;\n\t/**\n\t* @param {Halo2LibWasm} lib_wasm\n\t* @returns {JsCircuitValue256}\n\t*/\n\tto_circuit_value_256(lib_wasm: Halo2LibWasm): JsCircuitValue256;\n}\ndeclare class Bn254G1AffinePoint {\n\tfree(): void;\n\t/**\n\t* @returns {Bn254FqPoint}\n\t*/\n\tx(): Bn254FqPoint;\n\t/**\n\t* @returns {Bn254FqPoint}\n\t*/\n\ty(): Bn254FqPoint;\n}\ndeclare class Bn254G2AffinePoint {\n\tfree(): void;\n\t/**\n\t* @returns {Bn254Fq2Point}\n\t*/\n\tx(): Bn254Fq2Point;\n\t/**\n\t* @returns {Bn254Fq2Point}\n\t*/\n\ty(): Bn254Fq2Point;\n}\ndeclare class Halo2LibWasm {\n\tfree(): void;\n\t/**\n\t* Takes in CircuitValue256 in hi-lo form and loads internal CircuitBn254Fq type (we use 3 limbs of 88 bits).\n\t* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere.\n\t* @param {JsCircuitValue256} val\n\t* @returns {Bn254FqPoint}\n\t*/\n\tload_bn254_fq(val: JsCircuitValue256): Bn254FqPoint;\n\t/**\n\t* Doesn't range check limbs of g1_point.\n\t* Does not allow you to load identity point.\n\t* @param {JsCircuitBn254G1Affine} point\n\t* @returns {Bn254G1AffinePoint}\n\t*/\n\tload_bn254_g1(point: JsCircuitBn254G1Affine): Bn254G1AffinePoint;\n\t/**\n\t* `g1_points` should be array of `CircuitBn254G1Affine` in hi-lo form.\n\t* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere.\n\t* Prevents any g1_points from being identity.\n\t* @param {Array<any>} g1_points\n\t* @returns {Bn254G1AffinePoint}\n\t*/\n\tbn254_g1_sum(g1_points: Array<any>): Bn254G1AffinePoint;\n\t/**\n\t* `g1_point_1` and `g1_point_2` are `CircuitBn254G1Affine` points in hi-lo form.\n\t* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere\n\t* and also it constraints that g1_point_1.x != g1_point_2.x\n\t* Prevents any g1_points from being identity.\n\t* @param {JsCircuitBn254G1Affine} g1_point_1\n\t* @param {JsCircuitBn254G1Affine} g1_point_2\n\t* @returns {Bn254G1AffinePoint}\n\t*/\n\tbn254_g1_sub_unequal(g1_point_1: JsCircuitBn254G1Affine, g1_point_2: JsCircuitBn254G1Affine): Bn254G1AffinePoint;\n\t/**\n\t* Doesn't range check limbs of g2_point.\n\t* Does not allow you to load identity point.\n\t* @param {JsCircuitBn254G2Affine} point\n\t* @returns {Bn254G2AffinePoint}\n\t*/\n\tload_bn254_g2(point: JsCircuitBn254G2Affine): Bn254G2AffinePoint;\n\t/**\n\t* `g2_points` should be array of `CircuitBn254G2Affine` in hi-lo form.\n\t* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere.\n\t* Prevents any g2_points from being identity.\n\t* @param {Array<any>} g2_points\n\t* @returns {Bn254G2AffinePoint}\n\t*/\n\tbn254_g2_sum(g2_points: Array<any>): Bn254G2AffinePoint;\n\t/**\n\t* Verifies that e(lhs_g1, lhs_g2) = e(rhs_g1, rhs_g2) by checking e(lhs_g1, lhs_g2)*e(-rhs_g1, rhs_g2) === 1\n\t* Returns [CircuitValue] for the result as a boolean (1 if signature verification is successful).\n\t* None of the points should be identity.\n\t* @param {Bn254G1AffinePoint} lhs_g1\n\t* @param {Bn254G2AffinePoint} lhs_g2\n\t* @param {Bn254G1AffinePoint} rhs_g1\n\t* @param {Bn254G2AffinePoint} rhs_g2\n\t* @returns {number}\n\t*/\n\tbn254_pairing_check(lhs_g1: Bn254G1AffinePoint, lhs_g2: Bn254G2AffinePoint, rhs_g1: Bn254G1AffinePoint, rhs_g2: Bn254G2AffinePoint): number;\n\t/**\n\t* Doesn't range check limbs of point.\n\t* Pubkey is a point on\n\t* @param {JsCircuitSecp256k1Affine} point\n\t* @returns {Secp256k1AffinePoint}\n\t*/\n\tload_secp256k1_pubkey(point: JsCircuitSecp256k1Affine): Secp256k1AffinePoint;\n\t/**\n\t* Assumes all `JsCircuitValue256` limbs have been range checked to be `u128`.\n\t* @param {Secp256k1AffinePoint} pubkey\n\t* @param {JsCircuitValue256} r\n\t* @param {JsCircuitValue256} s\n\t* @param {JsCircuitValue256} msg_hash\n\t* @returns {number}\n\t*/\n\tverify_secp256k1_ecdsa_signature(pubkey: Secp256k1AffinePoint, r: JsCircuitValue256, s: JsCircuitValue256, msg_hash: JsCircuitValue256): number;\n\t/**\n\t* @param {bigint} sk\n\t* @param {bigint} msg_hash\n\t* @param {bigint} k\n\t* @returns {number}\n\t*/\n\tecdsa_benchmark(sk: bigint, msg_hash: bigint, k: bigint): number;\n\t/**\n\t* @param {number} hi\n\t* @param {number} lo\n\t* @returns {JsCircuitValue256}\n\t*/\n\tto_js_circuit_value_256(hi: number, lo: number): JsCircuitValue256;\n\t/**\n\t* @param {JsCircuitValue256} x\n\t* @param {JsCircuitValue256} y\n\t* @returns {JsCircuitBn254G1Affine}\n\t*/\n\tto_js_circuit_bn254_g1_affine(x: JsCircuitValue256, y: JsCircuitValue256): JsCircuitBn254G1Affine;\n\t/**\n\t* @param {JsCircuitValue256} c0\n\t* @param {JsCircuitValue256} c1\n\t* @returns {JsCircuitBn254Fq2}\n\t*/\n\tto_js_circuit_bn254_fq2(c0: JsCircuitValue256, c1: JsCircuitValue256): JsCircuitBn254Fq2;\n\t/**\n\t* @param {JsCircuitBn254Fq2} x\n\t* @param {JsCircuitBn254Fq2} y\n\t* @returns {JsCircuitBn254G2Affine}\n\t*/\n\tto_js_circuit_bn254_g2_affine(x: JsCircuitBn254Fq2, y: JsCircuitBn254Fq2): JsCircuitBn254G2Affine;\n\t/**\n\t* @param {JsCircuitValue256} x\n\t* @param {JsCircuitValue256} y\n\t* @returns {JsCircuitSecp256k1Affine}\n\t*/\n\tto_js_circuit_secp256k1_affine(x: JsCircuitValue256, y: JsCircuitValue256): JsCircuitSecp256k1Affine;\n\t/**\n\t* @param {Halo2Wasm} circuit\n\t*/\n\tconstructor(circuit: Halo2Wasm);\n\t/**\n\t*/\n\tconfig(): void;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tadd(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tsub(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t* @returns {number}\n\t*/\n\tneg(a: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tmul(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @param {number} c\n\t* @returns {number}\n\t*/\n\tmul_add(a: number, b: number, c: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tmul_not(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t*/\n\tassert_bit(a: number): void;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tdiv_unsafe(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {string} b\n\t*/\n\tassert_is_const(a: number, b: string): void;\n\t/**\n\t* @param {Uint32Array} a\n\t* @param {Uint32Array} b\n\t* @returns {number}\n\t*/\n\tinner_product(a: Uint32Array, b: Uint32Array): number;\n\t/**\n\t* @param {Uint32Array} a\n\t* @returns {number}\n\t*/\n\tsum(a: Uint32Array): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tand(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tor(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t* @returns {number}\n\t*/\n\tnot(a: number): number;\n\t/**\n\t* @param {number} a\n\t* @returns {number}\n\t*/\n\tdec(a: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @param {number} sel\n\t* @returns {number}\n\t*/\n\tselect(a: number, b: number, sel: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @param {number} c\n\t* @returns {number}\n\t*/\n\tor_and(a: number, b: number, c: number): number;\n\t/**\n\t* @param {Uint32Array} a\n\t* @returns {Uint32Array}\n\t*/\n\tbits_to_indicator(a: Uint32Array): Uint32Array;\n\t/**\n\t* @param {number} a\n\t* @param {string} b\n\t* @returns {Uint32Array}\n\t*/\n\tidx_to_indicator(a: number, b: string): Uint32Array;\n\t/**\n\t* @param {Uint32Array} a\n\t* @param {Uint32Array} indicator\n\t* @returns {number}\n\t*/\n\tselect_by_indicator(a: Uint32Array, indicator: Uint32Array): number;\n\t/**\n\t* @param {Uint32Array} a\n\t* @param {number} idx\n\t* @returns {number}\n\t*/\n\tselect_from_idx(a: Uint32Array, idx: number): number;\n\t/**\n\t* @param {number} a\n\t* @returns {number}\n\t*/\n\tis_zero(a: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @returns {number}\n\t*/\n\tis_equal(a: number, b: number): number;\n\t/**\n\t* @param {number} a\n\t* @param {string} num_bits\n\t* @returns {Uint32Array}\n\t*/\n\tnum_to_bits(a: number, num_bits: string): Uint32Array;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t*/\n\tconstrain_equal(a: number, b: number): void;\n\t/**\n\t* @param {number} a\n\t* @param {string} b\n\t*/\n\trange_check(a: number, b: string): void;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @param {string} size\n\t*/\n\tcheck_less_than(a: number, b: number, size: string): void;\n\t/**\n\t* @param {number} a\n\t* @param {string} b\n\t*/\n\tcheck_less_than_safe(a: number, b: string): void;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @param {string} size\n\t* @returns {number}\n\t*/\n\tis_less_than(a: number, b: number, size: string): number;\n\t/**\n\t* @param {number} a\n\t* @param {string} b\n\t* @returns {number}\n\t*/\n\tis_less_than_safe(a: number, b: string): number;\n\t/**\n\t* @param {number} a\n\t* @param {string} b\n\t* @param {string} size\n\t* @returns {Uint32Array}\n\t*/\n\tdiv_mod(a: number, b: string, size: string): Uint32Array;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @param {string} a_size\n\t* @param {string} b_size\n\t* @returns {Uint32Array}\n\t*/\n\tdiv_mod_var(a: number, b: number, a_size: string, b_size: string): Uint32Array;\n\t/**\n\t* @param {number} a\n\t* @param {number} b\n\t* @param {string} max_bits\n\t* @returns {number}\n\t*/\n\tpow_var(a: number, b: number, max_bits: string): number;\n\t/**\n\t* @param {Uint32Array} a\n\t* @returns {number}\n\t*/\n\tposeidon(a: Uint32Array): number;\n\t/**\n\t* @param {string} val\n\t* @returns {number}\n\t*/\n\twitness(val: string): number;\n\t/**\n\t* @param {string} val\n\t* @returns {number}\n\t*/\n\tconstant(val: string): number;\n\t/**\n\t* @param {Halo2Wasm} circuit\n\t* @param {number} a\n\t* @param {number} col\n\t*/\n\tmake_public(circuit: Halo2Wasm, a: number, col: number): void;\n\t/**\n\t* @param {Halo2Wasm} circuit\n\t* @param {number} a\n\t*/\n\tlog(circuit: Halo2Wasm, a: number): void;\n\t/**\n\t* @param {number} a\n\t* @returns {string}\n\t*/\n\tvalue(a: number): string;\n\t/**\n\t* @returns {number}\n\t*/\n\tlookup_bits(): number;\n}\ndeclare class Halo2Wasm {\n\tfree(): void;\n\t/**\n\t*/\n\tconstructor();\n\t/**\n\t*/\n\tclear(): void;\n\t/**\n\t*/\n\tclearInstances(): void;\n\t/**\n\t* @param {Uint8Array} proof\n\t*/\n\tverify(proof: Uint8Array): void;\n\t/**\n\t* @param {number} col\n\t* @returns {Uint32Array}\n\t*/\n\tgetInstances(col: number): Uint32Array;\n\t/**\n\t* @param {Uint32Array} instances\n\t* @param {number} col\n\t*/\n\tsetInstances(instances: Uint32Array, col: number): void;\n\t/**\n\t* @param {number} col\n\t* @returns {any}\n\t*/\n\tgetInstanceValues(col: number): any;\n\t/**\n\t* @param {CircuitConfig} config\n\t*/\n\tconfig(config: CircuitConfig): void;\n\t/**\n\t* @returns {CircuitStats}\n\t*/\n\tgetCircuitStats(): CircuitStats;\n\t/**\n\t* @returns {Uint8Array}\n\t*/\n\tgetVk(): Uint8Array;\n\t/**\n\t* @returns {Uint8Array}\n\t*/\n\tgetOnchainVk(): Uint8Array;\n\t/**\n\t* @returns {Uint8Array}\n\t*/\n\tgetPk(): Uint8Array;\n\t/**\n\t*/\n\tassignInstances(): void;\n\t/**\n\t*/\n\tmock(): void;\n\t/**\n\t* @param {Uint8Array} params\n\t*/\n\tloadParams(params: Uint8Array): void;\n\t/**\n\t* @param {Uint8Array} vk\n\t*/\n\tloadVk(vk: Uint8Array): void;\n\t/**\n\t* @param {Uint8Array} pk\n\t*/\n\tloadPk(pk: Uint8Array): void;\n\t/**\n\t*/\n\tgenVk(): void;\n\t/**\n\t*/\n\tgenPk(): void;\n\t/**\n\t* @returns {Uint8Array}\n\t*/\n\tprove(): Uint8Array;\n\t/**\n\t* For console logging only.\n\t* @param {string} a\n\t*/\n\tlog(a: string): void;\n}\ndeclare class JsCircuitBn254Fq2 {\n\tfree(): void;\n\t/**\n\t* @param {JsCircuitValue256} c0\n\t* @param {JsCircuitValue256} c1\n\t*/\n\tconstructor(c0: JsCircuitValue256, c1: JsCircuitValue256);\n\t/**\n\t*/\n\tc0: JsCircuitValue256;\n\t/**\n\t*/\n\tc1: JsCircuitValue256;\n}\ndeclare class JsCircuitBn254G1Affine {\n\tfree(): void;\n\t/**\n\t* @param {JsCircuitValue256} x\n\t* @param {JsCircuitValue256} y\n\t*/\n\tconstructor(x: JsCircuitValue256, y: JsCircuitValue256);\n\t/**\n\t*/\n\tx: JsCircuitValue256;\n\t/**\n\t*/\n\ty: JsCircuitValue256;\n}\ndeclare class JsCircuitBn254G2Affine {\n\tfree(): void;\n\t/**\n\t* @param {JsCircuitBn254Fq2} x\n\t* @param {JsCircuitBn254Fq2} y\n\t*/\n\tconstructor(x: JsCircuitBn254Fq2, y: JsCircuitBn254Fq2);\n\t/**\n\t*/\n\tx: JsCircuitBn254Fq2;\n\t/**\n\t*/\n\ty: JsCircuitBn254Fq2;\n}\ndeclare class JsCircuitSecp256k1Affine {\n\tfree(): void;\n\t/**\n\t* @param {JsCircuitValue256} x\n\t* @param {JsCircuitValue256} y\n\t*/\n\tconstructor(x: JsCircuitValue256, y: JsCircuitValue256);\n\t/**\n\t*/\n\tx: JsCircuitValue256;\n\t/**\n\t*/\n\ty: JsCircuitValue256;\n}\ndeclare class JsCircuitValue256 {\n\tfree(): void;\n\t/**\n\t* @param {number} hi\n\t* @param {number} lo\n\t*/\n\tconstructor(hi: number, lo: number);\n\t/**\n\t*/\n\thi: number;\n\t/**\n\t*/\n\tlo: number;\n}\ndeclare class Secp256k1AffinePoint {\n\tfree(): void;\n\t/**\n\t* @returns {Secp256k1FpPoint}\n\t*/\n\tx(): Secp256k1FpPoint;\n\t/**\n\t* @returns {Secp256k1FpPoint}\n\t*/\n\ty(): Secp256k1FpPoint;\n}\ndeclare class Secp256k1FpPoint {\n\tfree(): void;\n\t/**\n\t* @param {Halo2LibWasm} lib_wasm\n\t* @returns {JsCircuitValue256}\n\t*/\n\tto_circuit_value_256(lib_wasm: Halo2LibWasm): JsCircuitValue256;\n}\ndeclare class CircuitValue256 {\n\tprivate _value;\n\tprivate _circuitValue;\n\tprivate _halo2Lib;\n\tconstructor(_halo2Lib: Halo2LibWasm, { value, hi, lo, }: {\n\t\tvalue?: bigint | string | number;\n\t\thi?: CircuitValue;\n\t\tlo?: CircuitValue;\n\t});\n\thi(): CircuitValue;\n\tlo(): CircuitValue;\n\thex(): string;\n\tvalue(): bigint;\n\ttoCircuitValue(): CircuitValue;\n}\ndeclare class CircuitValue {\n\tprivate _value;\n\tprivate _cell;\n\tprivate _circuit;\n\tconstructor(circuit: Halo2LibWasm, { value, cell }: {\n\t\tvalue?: bigint | number | string;\n\t\tcell?: number;\n\t});\n\tcell(): number;\n\tvalue(): bigint;\n\tnumber(): number;\n\taddress(): string;\n\ttoCircuitValue256(): CircuitValue256;\n}\ninterface CircuitBn254Fq2 {\n\tc0: CircuitValue256;\n\tc1: CircuitValue256;\n}\ninterface CircuitBn254G1Affine {\n\tx: CircuitValue256;\n\ty: CircuitValue256;\n}\ninterface CircuitBn254G2Affine {\n\tx: CircuitBn254Fq2;\n\ty: CircuitBn254Fq2;\n}\ninterface CircuitSecp256k1Affine {\n\tx: CircuitValue256;\n\ty: CircuitValue256;\n}\ntype RawCircuitInput = string | number | bigint;\n/**\n * Creates a circuit variable from a number, bigint, or string.\n *\n * @param a The raw circuit input.\n * @returns The witness cell.\n */\ndeclare const witness: (a: RawCircuitInput) => CircuitValue;\n/**\n * Creates a circuit constant from a number, bigint, or string.\n *\n * @param a The raw circuit input.\n * @returns The constant cell.\n */\ndeclare const constant: (a: RawCircuitInput) => CircuitValue;\n/**\n * Adds two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The sum of the two circuit values.\n */\ndeclare const add: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Subtracts the second circuit value from the first circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The difference between the two circuit values.\n */\ndeclare const sub: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Negates a circuit value.\n *\n * @param a The circuit value to negate.\n * @returns The negation of the circuit value.\n */\ndeclare const neg: (a: CircuitValue) => CircuitValue;\n/**\n * Multiplies two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The product of the two circuit values.\n */\ndeclare const mul: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Multiplies two circuit values and adds a third circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The third circuit value.\n * @returns The result of multiplying the first two circuit values and adding the third circuit value.\n */\ndeclare const mulAdd: (a: CircuitValue, b: CircuitValue, c: CircuitValue) => CircuitValue;\n/**\n * Multiplies a circuit value by the negation of another circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of multiplying the first circuit value by the negation of the second circuit value.\n */\ndeclare const mulNot: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Asserts that a circuit value is a bit.\n *\n * @param a The circuit value to assert.\n */\ndeclare const assertBit: (a: CircuitValue) => void;\n/**\n * Asserts that a circuit value is a constant.\n *\n * @param a The circuit value to assert.\n * @param b The raw circuit input.\n */\ndeclare const assertIsConst: (a: CircuitValue, b: RawCircuitInput) => void;\n/**\n * Computes the inner product of two arrays of circuit values.\n *\n * @param a The first array of circuit values.\n * @param b The second array of circuit values.\n * @returns The inner product of the two arrays.\n */\ndeclare const innerProduct: (a: CircuitValue[], b: CircuitValue[]) => CircuitValue;\n/**\n * Computes the sum of an array of circuit values.\n *\n * @param arr The array of circuit values.\n * @returns The sum of the array of circuit values.\n */\ndeclare const sum: (arr: CircuitValue[]) => CircuitValue;\n/**\n * Performs a bitwise AND operation on two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of the bitwise AND operation.\n */\ndeclare const and: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise OR operation on two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of the bitwise OR operation.\n */\ndeclare const or: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise NOT operation on a circuit value.\n *\n * @param a The circuit value.\n * @returns The result of the bitwise NOT operation.\n */\ndeclare const not: (a: CircuitValue) => CircuitValue;\n/**\n * Decrements a circuit value by 1.\n *\n * @param a The circuit value.\n * @returns The decremented circuit value.\n */\ndeclare const dec: (a: CircuitValue) => CircuitValue;\n/**\n * Selects a circuit value based on a condition.\n *\n * @param a The first circuit value.\n * @param b The first circuit value.\n * @param sel The condition boolean circuit value.\n * @returns sel ? a : b\n */\ndeclare const select: (a: CircuitValue, b: CircuitValue, sel: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise OR-AND operation on three circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The third circuit value.\n * @returns The result of the OR-AND operation.\n */\ndeclare const orAnd: (a: CircuitValue, b: CircuitValue, c: CircuitValue) => CircuitValue;\n/**\n * Converts an array of circuit values to an indicator array.\n *\n * @param bits The array of circuit values.\n * @returns The indicator circuit value.\n */\ndeclare const bitsToIndicator: (bits: CircuitValue[]) => CircuitValue[];\n/**\n * Converts an index circuit value to an indicator circuit value.\n *\n * @param idx The index circuit value.\n * @param len The length of the indicator circuit value.\n * @returns The indicator circuit value.\n */\ndeclare const idxToIndicator: (idx: CircuitValue, len: RawCircuitInput) => CircuitValue[];\n/**\n * Selects circuit values from an array based on an indicator circuit value.\n *\n * @param arr The array of circuit values.\n * @param indicator The indicator circuit value.\n * @returns The selected circuit values.\n */\ndeclare const selectByIndicator: (arr: CircuitValue[], indicator: CircuitValue[]) => CircuitValue;\n/**\n * Selects a circuit value from an array based on an index circuit value.\n *\n * @param arr The array of circuit values.\n * @param idx The index circuit value.\n * @returns The selected circuit value.\n */\ndeclare const selectFromIdx: (arr: CircuitValue[], idx: CircuitValue) => CircuitValue;\n/**\n * Checks if a circuit value is zero.\n *\n * @param a The circuit value to check.\n * @returns The indicator circuit value representing whether the input is zero.\n */\ndeclare const isZero: (a: CircuitValue) => CircuitValue;\n/**\n * Checks if two circuit values are equal.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The indicator circuit value representing whether the two inputs are equal.\n */\ndeclare const isEqual: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Converts a circuit value to an array of bits.\n *\n * @param a The circuit value to convert.\n * @param len The length of the resulting bit array.\n * @returns The array of bits representing the input circuit value.\n */\ndeclare const numToBits: (a: CircuitValue, len: RawCircuitInput) => CircuitValue[];\n/**\n * Asserts that two circuit values are equal.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n */\ndeclare const checkEqual: (a: CircuitValue, b: CircuitValue) => void;\n/**\n * Checks if a circuit value is within a specified range.\n *\n * @param a The circuit value to check.\n * @param b The range of the circuit value.\n */\ndeclare const rangeCheck: (a: CircuitValue, b: RawCircuitInput) => void;\n/**\n * Checks if the first circuit value is less than the second circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The range of the circuit values.\n */\ndeclare const checkLessThan: (a: CircuitValue, b: CircuitValue, c?: string) => void;\n/**\n * Checks if the first circuit value is less than the second circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The range of the circuit values.\n * @returns The indicator circuit value representing whether the first input is less than the second input.\n */\ndeclare const isLessThan: (a: CircuitValue, b: CircuitValue, c?: string) => CircuitValue;\n/**\n * Divides two circuit values and returns the quotient.\n *\n * @param a The dividend circuit value.\n * @param b The divisor circuit value.\n * @returns The quotient.\n *\n */\ndeclare const div: (a: CircuitValue, b: CircuitValue, c?: string, d?: string) => CircuitValue;\n/**\n * Divides two circuit values and returns the remainder.\n *\n * @param a The dividend circuit value.\n * @param b The divisor circuit value.\n * @returns The remainder.\n *\n */\ndeclare const mod: (a: CircuitValue, b: CircuitValue, c?: string, d?: string) => CircuitValue;\n/**\n * Raises a circuit value to the power of another circuit value.\n *\n * @param a The base circuit value.\n * @param b The exponent circuit value.\n * @returns The result of the exponentiation.\n */\ndeclare const pow: (a: CircuitValue, b: CircuitValue, c?: string) => CircuitValue;\n/**\n * Computes the Poseidon hash of multiple circuit values.\n *\n * @param args The circuit values to hash.\n * @returns The hash value.\n */\ndeclare const poseidon: (...args: CircuitValue[]) => CircuitValue;\n/**\n * Retrieves the value of a circuit value.\n *\n * @param a The circuit value.\n * @returns The value of the circuit value.\n */\ndeclare const value: (a: CircuitValue) => any;\n/**\n * Logs the provided *circuit* values to the console. Use `console.log` for normal logging.\n *\n * @param args The `CircuitValue`s to log.\n */\ndeclare const log: (...args: any) => void;\ndeclare const console: {\n\t/**\n\t * Logs any *non CircuitValue* to the console. Use `log` for logging `CircuitValue`s.\n\t * @param args The values to log.\n\t */\n\tlog: (...args: any) => void;\n};\ndeclare const ecdsaBenchmark: (sk: bigint, msg_hash: bigint, k: bigint) => CircuitValue;\n/**\n * Creates new `CircuitValue256` and range checks `hi, lo` to be `uint128`s.\n * @param hi\n * @param lo\n * @returns\n */\ndeclare const newCircuitValue256: (hi: CircuitValue, lo: CircuitValue) => CircuitValue256;\n//ecc\n/**\n *\n * @param val The field point to load, in hi-lo form. The hi, lo values must have been constrained to be `uint128`s.\n * @returns `Bn254FqPoint` whose internals are opaque to the user.\n */\ndeclare const loadBn254Fq: (val: CircuitValue256) => Bn254FqPoint;\n/**\n *\n * @param val\n * @returns `val` in hi-lo form\n */\ndeclare const convertBn254FqToCircuitValue256: (val: Bn254FqPoint) => CircuitValue256;\n/**\n * @param point The affine point to load, with coordinates `CircuitValue256`. The hi, lo values must have been constrained to be `uint128`s.\n * @returns `Bn254G1AffinePoint`, which has been constrained to lie on the curve. Currently this point is not allowed to be identity (0, 0).\n */\ndeclare const loadBn254G1: (point: CircuitBn254G1Affine) => Bn254G1AffinePoint;\n/**\n * Sums the values of the provided G1 affine points\n *\n * @param points - The array of `CircuitBn254G1Affine` points. All coordinates are in hi, lo form, and we assume they have been range checked to be `uint128`s.\n * @returns The sum of all these points as `Bn254G1AffinePoint`.\n */\ndeclare const bn254G1Sum: (points: Array<CircuitBn254G1Affine>) => Bn254G1AffinePoint;\n/**\n * Subtracts the 2 points and returns the value. Constrains that the points are not equal and also one is not the negative of the other (this would be a point doubling, which requires a different formula).\n *\n * @returns The subtraction of these points.\n * @param g1Point1 - G1 point, x,y in hi lo format for each coordinate\n * @param g1Point2 - G1 point, x,y in hi lo format for each coordinate\n */\ndeclare const bn254G1SubUnequal: (g1Point1: CircuitBn254G1Affine, g1Point2: CircuitBn254G1Affine) => Bn254G1AffinePoint;\n/**\n * @param point The affine point to load, with coordinates `CircuitBn254Fq2`. The hi, lo values must have been constrained to be `uint128`s.\n * @returns `Bn254G2AffinePoint`, which has been constrained to lie on the curve. Currently this point is not allowed to be identity (Fq2(0), Fq2(0)).\n */\ndeclare const loadBn254G2: (point: CircuitBn254G2Affine) => Bn254G2AffinePoint;\n/**\n * Sums the values of the provided G2 affine points\n *\n * @param points - The array of `CircuitBn254G2Affine` points. All coordinates are `CircuitBn254Fq2`, whose coordinates are in hi, lo form, and we assume the hi, lo's have been range checked to be `uint128`s.\n * @returns The sum of all these points as `Bn254G2AffinePoint`.\n */\ndeclare const bn254G2Sum: (points: Array<CircuitBn254G2Affine>) => Bn254G2AffinePoint;\n/**\n * Verifies that e(lhsG1, lhsG2) = e(rhsG1, rhsG2) by checking e(lhsG1, lhsG2)*e(-rhsG1, rhsG2) === 1\n * None of the points should be identity.\n *\n * @param lhsG1\n * @param lhsG2\n * @param rhsG1\n * @param rhsG2\n * @returns [CircuitValue] for the result as a boolean (1 if signature verification is successful).\n */\ndeclare const bn254PairingCheck: (lhsG1: Bn254G1AffinePoint, lhsG2: Bn254G2AffinePoint, rhsG1: Bn254G1AffinePoint, rhsG2: Bn254G2AffinePoint) => CircuitValue;\n/**\n * @param pubkey The public key to load, in the form of an affine elliptic curve point `(x, y)` where `x, y` have type `CircuitValue256`. The hi, lo values of each `CircuitValue256` must have been constrained to be `uint128`s.\n * @returns `Secp256k1AffinePoint`, the public key as a loaded elliptic curve point. This has been constrained to lie on the curve. The public key is constrained to not be the identity (0, 0).\n */\ndeclare const loadSecp256k1Pubkey: (pubkey: CircuitSecp256k1Affine) => Secp256k1AffinePoint;\n/**\n *\n * Verifies the ECDSA signature `(r, s)` with message hash `msgHash` using the secp256k1 public key `pubkey`. Returns 1 if the signature is valid, 0 otherwise.\n * @param pubkey\n * @param r\n * @param s\n * @param msgHash\n * @returns\n */\ndeclare const verifySecp256k1ECDSASignature: (pubkey: Secp256k1AffinePoint, r: CircuitValue256, s: CircuitValue256, msgHash: CircuitValue256) => CircuitValue;\n\n{};\n";